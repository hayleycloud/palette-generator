function gplColor(c) {
    const txt = c.toString();
    const len = txt.length;
    if (len == 1) {
        return "  " + txt;
    }
    else if (len == 2) {
        return " " + txt;
    }
    else {
        return txt;
    }
}
function createGPLFile(name, colors) {
    let file = "";
    file += "GIMP Palette\n";
    file += "#\n";
    file += "# Generated by Hayley Hatton's Mathematical Palette Generator\n";
    file += "#\n";
    colors.forEach((color, index) => {
        file += gplColor(color.r) + " ";
        file += gplColor(color.g) + " ";
        file += gplColor(color.b) + "\tIndex " + index + "\n";
    });
    return file;
}
function downloadFile(name, content) {
    const store = document.createElement("a");
    store.setAttribute("href", "data:text/plain;charset=utf-8," + encodeURIComponent(content));
    store.setAttribute("download", name);
    document.body.appendChild(store);
    store.click();
    document.body.removeChild(store);
}
function downloadAsGPLFile() {
    const nameEl = document.getElementById("pal-name");
    const name = nameEl.value + ".gpl";
    const colors = getColorsFrom(getSamplers());
    downloadFile(name, createGPLFile(name, colors));
}
function saveBrowser() {
}
function loadBrowser() {
}
function spliceProperty(property) {
    const idEnd = property.indexOf(':');
    const identifier = property.substr(0, idEnd);
    const params = property.substr(idEnd + 1);
    return [identifier, params];
}
function saveLocal() {
    let file = "V10\n";
    const palName = document.getElementById("pal-name");
    file += "name:" + palName.value + "\n";
    const maxColors = document.getElementById("max-colors");
    file += "size:" + maxColors.value + "\n";
    getSamplers().forEach(sampler => {
        file += sampler.serialize() + "\n";
    });
    downloadFile(palName.value + ".psf", file);
}
function loadLocal(data) {
    const parts = data.split('\n');
    if (parts[0] != "V10") {
        alert("Version not supported!");
        return;
    }
    const palName = document.getElementById("pal-name");
    palName.value = spliceProperty(parts[1])[1];
    const maxColors = document.getElementById("max-colors");
    maxColors.value = spliceProperty(parts[2])[1];
    resetSamplers();
    const props = parts.splice(3);
    props.forEach(prop => {
        const [identifier, params] = spliceProperty(prop);
        let sampler = null;
        switch (identifier) {
            case "LinearRGBSampler":
                sampler = LinearRGBSampler.deserialize(params);
                break;
            case "LinearSRGBSampler":
                sampler = LinearSRGBSampler.deserialize(params);
                break;
            case "BezierFastSampler":
                sampler = BezierFastSampler.deserialize(params);
                break;
            case "BezierQuadraticSampler":
                sampler = BezierQuadraticSampler.deserialize(params);
                break;
            case "HSVSampler":
                sampler = HSVSampler.deserialize(params);
                break;
            default:
                return;
        }
        sampler._htmlID = genSamplerID();
        getSamplers().push(sampler);
        addPropertyForExisting(sampler);
    });
    syncPaletteView();
    clampPropertyShiftBtns();
}
function createSettingsTable() {
    const tbl = document.createElement("table");
    tbl.id = "settings";
    const thead = document.createElement("thead");
    const theadTR = document.createElement("tr");
    const theadTH = document.createElement("th");
    theadTH.textContent = "Settings";
    theadTH.colSpan = 2;
    const tbody = document.createElement("tbody");
    const palNameTR = document.createElement("tr");
    const palNameTH = document.createElement("th");
    palNameTH.textContent = "Name:";
    const palNameTD = document.createElement("td");
    const palName = document.createElement("input");
    palName.id = "pal-name";
    palName.type = "text";
    palName.value = "My Palette";
    palName.minLength = 1;
    palName.oninput = (event) => {
        validate();
    };
    palNameTD.appendChild(palName);
    const maxColorTR = document.createElement("tr");
    const maxColorTH = document.createElement("th");
    maxColorTH.textContent = "Max Palette Size:";
    const maxColorTD = document.createElement("td");
    const maxColors = document.createElement("input");
    maxColors.id = "max-colors";
    maxColors.type = "number";
    maxColors.min = "0";
    maxColors.step = "1";
    maxColors.value = "255";
    maxColors.onchange = () => {
        let value = parseInt(maxColors.value);
        value = Math.max(value, parseInt(maxColors.min));
        maxColors.value = value.toString();
        validate();
    };
    maxColorTD.appendChild(maxColors);
    const errorsTR = document.createElement("tr");
    const errorsTH = document.createElement("th");
    errorsTH.textContent = "Errors:";
    const errorsTD = document.createElement("td");
    errorsTD.id = "errors";
    errorsTD.className = "errors-none";
    errorsTD.innerHTML = "<span class=\"errors-none\">No errors :)</span>";
    theadTR.appendChild(theadTH);
    thead.appendChild(theadTR);
    palNameTR.append(palNameTH, palNameTD);
    maxColorTR.append(maxColorTH, maxColorTD);
    errorsTR.append(errorsTH, errorsTD);
    tbody.append(palNameTR, maxColorTR, errorsTR);
    tbl.append(thead, tbody);
    return tbl;
}
function createPaletteTable(cols, colors) {
    const tbody = document.createElement("tbody");
    const rows = Math.ceil(colors.length / cols);
    for (let row = 0; row < rows; row++) {
        const tr = document.createElement("tr");
        let colCount = ((row + 1) == rows) ? colors.length % cols : cols;
        if (colCount == 0)
            colCount = cols;
        for (let col = 0; col < colCount; col++) {
            const td = document.createElement("td");
            const colorIndex = (row * cols) + col;
            const color = colors[colorIndex];
            const colorHex = rgb2str(color);
            td.style.backgroundColor = colorHex;
            td.title = colorHex +
                " (R: " + color.r + ", G: " + color.g + ", B: " + color.b + ")";
            tr.appendChild(td);
        }
        tbody.appendChild(tr);
    }
    return tbody;
}
function createPaletteView(cols, colors) {
    const tbl = document.createElement("table");
    tbl.classList.add("palette-view");
    tbl.id = "palette-view";
    const thead = document.createElement("thead");
    const theadTR = document.createElement("tr");
    const theadTH = document.createElement("th");
    theadTH.textContent = "Palette View";
    theadTH.colSpan = cols;
    const theadTR2 = document.createElement("tr");
    const theadTD = document.createElement("td");
    theadTD.colSpan = cols;
    const colSizer = document.createElement("input");
    colSizer.type = "number";
    colSizer.id = "col-count";
    colSizer.min = "1";
    colSizer.value = cols.toString();
    colSizer.step = "1";
    colSizer.size = 3;
    colSizer.onchange = () => {
        let value = parseInt(colSizer.value);
        value = Math.max(value, parseInt(colSizer.min));
        colSizer.value = value.toString();
        syncPaletteView();
    };
    const colSizeLbl = document.createElement("label");
    colSizeLbl.htmlFor = "col-count";
    colSizeLbl.textContent = "Columns: ";
    theadTD.append(colSizeLbl, colSizer);
    theadTR2.appendChild(theadTD);
    const theadTR3 = document.createElement("tr");
    const theadTD2 = document.createElement("td");
    theadTD2.colSpan = cols;
    const colorCount = document.createElement("input");
    colorCount.type = "number";
    colorCount.id = "color-count";
    colorCount.value = colors.length.toString();
    colorCount.step = "1";
    colorCount.size = 5;
    colorCount.readOnly = true;
    const colorCountLbl = document.createElement("label");
    colorCountLbl.htmlFor = "color-count";
    colorCountLbl.textContent = "# Colors: ";
    theadTD2.append(colorCountLbl, colorCount);
    theadTR3.appendChild(theadTD2);
    const tbody = createPaletteTable(cols, colors);
    theadTR.appendChild(theadTH);
    thead.append(theadTR, theadTR2, theadTR3);
    tbl.appendChild(thead);
    tbl.appendChild(tbody);
    return tbl;
}
function createNewPaletteViewFrom(cols, samplers) {
    const colors = getColorsFrom(samplers);
    const paletteView = createPaletteView(cols, colors);
    return paletteView;
}
function updatePaletteViewFrom(samplers) {
    const colSizer = document.getElementById("col-count");
    const numCols = parseInt(colSizer.value);
    const preexisting = document.getElementById("palette-view");
    preexisting.remove();
    const readoutSect = document.getElementById("readout-section");
    const paletteView = createNewPaletteViewFrom(numCols, samplers);
    readoutSect.appendChild(paletteView);
}
function syncPaletteView() {
    updatePaletteViewFrom(getSamplers());
    validate();
}
function clampPropertyShiftBtns() {
    const properties = document.getElementById("properties");
    const numChildren = properties.children.length;
    const lastIndex = properties.children.length - 1;
    if (numChildren == 0)
        return;
    const shiftBtns = properties.getElementsByClassName("shifter");
    for (let i = 0; i < shiftBtns.length; i++) {
        shiftBtns[i].disabled = false;
    }
    const shiftUp = properties.children[0].getElementsByClassName("shift-up")[0];
    const shiftDn = properties.children[lastIndex].getElementsByClassName("shift-down")[0];
    shiftUp.disabled = true;
    shiftDn.disabled = true;
}
function shiftPropertyUp(id) {
    const properties = document.getElementById("properties");
    const lastChildIndex = properties.children.length - 1;
    let prev = null;
    for (let i = 0; i < properties.children.length; i++) {
        const node = properties.children[i];
        if (prev && node.id == id) {
            properties.insertBefore(node, prev);
            const prevSampler = getSamplers()[i - 1];
            const sampler = getSamplers()[i];
            const preSamples = i > 1 ? getSamplers().splice(0, i - 1) : [];
            const postSamples = i < lastChildIndex ? getSamplers().splice(i + 1) : [];
            setSamplers(preSamples
                .concat(sampler)
                .concat(prevSampler)
                .concat(postSamples));
            syncPaletteView();
            break;
        }
        prev = node;
    }
    clampPropertyShiftBtns();
}
function shiftPropertyDown(id) {
    const properties = document.getElementById("properties");
    const lastChildIndex = properties.children.length - 1;
    let prev = null;
    for (let i = lastChildIndex; i >= 0; i--) {
        const node = properties.children[i];
        if (prev && node.id == id) {
            properties.insertBefore(prev, node);
            const prevSampler = getSamplers()[i + 1];
            const sampler = getSamplers()[i];
            const preSamples = i > 0 ? getSamplers().splice(0, i) : [];
            const postSamples = i < lastChildIndex ? getSamplers().splice(i + 2) : [];
            setSamplers(preSamples
                .concat(prevSampler)
                .concat(sampler)
                .concat(postSamples));
            syncPaletteView();
            break;
        }
        prev = node;
    }
    clampPropertyShiftBtns();
}
function addPropertyActionsTo(tr, id, htmlID) {
    const moveUp = document.createElement("button");
    moveUp.classList.add("shifter", "shift-up");
    moveUp.type = "button";
    moveUp.textContent = "";
    moveUp.onclick = () => { shiftPropertyUp(id); };
    const moveDown = document.createElement("button");
    moveDown.classList.add("shifter", "shift-down");
    moveDown.type = "button";
    moveDown.textContent = "";
    moveDown.onclick = () => { shiftPropertyDown(id); };
    const remover = document.createElement("a");
    remover.classList.add("remover");
    remover.textContent = "Remove";
    remover.onclick = () => { removeProperty(htmlID); };
    tr.children[2].append(moveUp, document.createElement("br"), remover, document.createElement("br"), moveDown);
}
function addPropertyForExisting(sampler) {
    const properties = document.getElementById("properties");
    const row = sampler.createHTML();
    addPropertyActionsTo(row, "sampler-" + sampler.htmlID(), sampler.htmlID());
    properties.appendChild(row);
}
function addNewProperty(selector) {
    const properties = document.getElementById("properties");
    let sampler = null;
    switch (selector.value) {
        case "linear":
            sampler = new LinearRGBSampler(genSamplerID());
            break;
        case "linear-srgb":
            sampler = new LinearSRGBSampler(genSamplerID());
            break;
        case "bezier-fast":
            sampler = new BezierFastSampler(genSamplerID());
            break;
        case "bezier-quad":
            sampler = new BezierQuadraticSampler(genSamplerID());
            break;
        case "hsv":
            sampler = new HSVSampler(genSamplerID());
            break;
    }
    const samplerHtml = sampler.createHTML();
    addPropertyActionsTo(samplerHtml, "sampler-" + sampler.htmlID(), sampler.htmlID());
    properties.appendChild(samplerHtml);
    getSamplers().push(sampler);
    syncPaletteView();
    clampPropertyShiftBtns();
}
function createAddNewProperty() {
    const tfoot = document.createElement("tfoot");
    const tr = document.createElement("tr");
    const td = [
        document.createElement("td"),
        document.createElement("td"),
        document.createElement("td")
    ];
    td[0].textContent = "Add New:";
    td[0].classList.add("pseudo-th");
    const selector = document.createElement("select");
    const select = document.createElement("option");
    select.text = "-- Select Mode --";
    select.disabled = true;
    select.hidden = true;
    select.selected = true;
    selector.add(select);
    const categories = [
        {
            name: "Linear Gradients",
            options: [
                { id: "linear", title: "Linear (RGB)" },
                { id: "linear-srgb", title: "Linear (sRGB)" }
            ]
        },
        {
            name: "Exponential Gradients",
            options: [
                { id: "bezier-fast", title: "Bézier (Fast)" },
                { id: "bezier-quad", title: "Bézier" }
            ]
        },
        {
            name: "Hue-Saturation-Value",
            options: [
                { id: "hsv", title: "HSV" }
            ]
        }
    ];
    categories.forEach(category => {
        const categoryOpt = document.createElement("option");
        categoryOpt.text = category.name;
        categoryOpt.disabled = true;
        selector.add(categoryOpt);
        category.options.forEach(option => {
            const optionOpt = document.createElement("option");
            optionOpt.text = option.title;
            optionOpt.value = option.id;
            selector.add(optionOpt);
        });
    });
    td[1].appendChild(selector);
    const addBtn = document.createElement("button");
    addBtn.type = "button";
    addBtn.onclick = () => {
        addNewProperty(selector);
        selector.selectedIndex = 0;
        addBtn.disabled = true;
    };
    addBtn.textContent = "Add";
    addBtn.disabled = true;
    selector.onchange = () => { addBtn.disabled = false; };
    td[2].appendChild(addBtn);
    tr.append(td[0], td[1], td[2]);
    tfoot.appendChild(tr);
    return tfoot;
}
function removeProperty(id) {
    document.getElementById("sampler-" + id).remove();
    getSamplers().forEach((sampler, index) => {
        if (sampler.htmlID() == id)
            getSamplers().splice(index, 1);
    });
    syncPaletteView();
}
function createPropertiesList() {
    const tbl = document.createElement("table");
    tbl.classList.add("properties-list");
    const thead = document.createElement("thead");
    const theadTR = document.createElement("tr");
    const theadTHs = [
        document.createElement("th"),
        document.createElement("th"),
        document.createElement("th")
    ];
    theadTHs[0].textContent = "Type";
    theadTHs[1].textContent = "Parameters";
    theadTHs[2].textContent = "Actions";
    theadTR.append(theadTHs[0], theadTHs[1], theadTHs[2]);
    thead.append(theadTR);
    const tbody = document.createElement("tbody");
    tbody.id = "properties";
    getSamplers().forEach(sampler => {
        const samplerHtml = sampler.createHTML();
        addPropertyActionsTo(samplerHtml, sampler.id(), sampler.htmlID());
        tbody.appendChild(samplerHtml);
    });
    const tfoot = createAddNewProperty();
    tbl.append(thead, tbody, tfoot);
    return tbl;
}
function createFileOps() {
    const tbl = document.createElement("table");
    tbl.id = "file-ops";
    const thead = document.createElement("thead");
    const theadTR = document.createElement("tr");
    const theadTH = document.createElement("th");
    theadTH.textContent = "File";
    theadTH.colSpan = 2;
    theadTR.appendChild(theadTH);
    thead.appendChild(theadTR);
    const tbody = document.createElement("tbody");
    const trs = [
        document.createElement("tr"),
        document.createElement("tr"),
        document.createElement("tr")
    ];
    const downloadTH = document.createElement("th");
    const downloadTD = document.createElement("td");
    downloadTH.textContent = "Download Palette: ";
    const downloadGPL = document.createElement("button");
    downloadGPL.type = "button";
    downloadGPL.id = "download-gpl";
    downloadGPL.textContent = "Download GPL";
    downloadGPL.onclick = () => { downloadAsGPLFile(); };
    downloadTD.appendChild(downloadGPL);
    trs[0].append(downloadTH, downloadTD);
    const loadTH = document.createElement("th");
    const loadTD = document.createElement("td");
    loadTH.textContent = "Load Session: ";
    const load = document.createElement("input");
    load.type = "file";
    load.accept = ".psf";
    load.id = "local-loader";
    load.addEventListener("change", (event) => {
        load.files[0].text().then((file) => {
            loadLocal(file);
        });
    });
    loadTD.appendChild(load);
    trs[1].append(loadTH, loadTD);
    const saveTH = document.createElement("th");
    const saveTD = document.createElement("td");
    saveTH.textContent = "Save Session: ";
    const save = document.createElement("button");
    save.type = "button";
    save.textContent = "Save";
    save.onclick = saveLocal;
    saveTD.appendChild(save);
    trs[2].append(saveTH, saveTD);
    tbody.append(trs[0], trs[1], trs[2]);
    tbl.append(thead, tbody);
    return tbl;
}
function createReadoutSection() {
    const div = document.createElement("div");
    div.classList.add("centered");
    div.id = "readout-section";
    return div;
}
function createInputSection() {
    const div = document.createElement("div");
    div.id = "input-section";
    return div;
}
function createPage() {
    const app = document.getElementById("app");
    const settings = createSettingsTable();
    getSamplers().push(new LinearRGBSampler(genSamplerID()));
    const appSplit = document.createElement("div");
    //appSplit.id = "app-split";
    const readoutSect = createReadoutSection();
    readoutSect.appendChild(createNewPaletteViewFrom(8, getSamplers()));
    const inputSect = createInputSection();
    inputSect.appendChild(createPropertiesList());
    appSplit.append(readoutSect, inputSect);
    app.append(settings, appSplit, createFileOps());
    clampPropertyShiftBtns();
    if (window.innerHeight > window.innerWidth)
        appSplit.id = "app-split-v";
    else
        appSplit.id = "app-split-h";
    window.onresize = (event) => {
        const id = window.innerHeight > window.innerWidth
            ? "app-split-v" : "app-split-h";
        appSplit.id = id;
    };
}
function setNoErrorState() {
    const errors = document.getElementById("errors");
    errors.className = "errors-none";
    errors.textContent = "No errors :)";
    const paletteView = document.getElementById("palette-view");
    paletteView.classList.remove("bad-palette-view");
    document.getElementById("download-gpl").disabled = false;
}
function setErrorState() {
    const errors = document.getElementById("errors");
    errors.className = "errors-some";
    const paletteView = document.getElementById("palette-view");
    paletteView.classList.add("bad-palette-view");
    document.getElementById("download-gpl").disabled = true;
}
function setErrors(errors) {
    if (errors.length > 0) {
        setErrorState();
        const errorsEl = document.getElementById("errors");
        errorsEl.textContent = errors.reduce((errList, error) => {
            return errList + '\n' + error;
        });
    }
    else {
        setNoErrorState();
    }
}
function validate() {
    const errors = [];
    const pvColors = document.querySelectorAll("#palette-view > tbody > tr > td");
    const maxColorsEl = document.getElementById("max-colors");
    const maxColors = parseInt(maxColorsEl.value);
    if (maxColors > 0 && pvColors.length > maxColors) {
        errors.push("More colors than max palette size!");
    }
    const filename = document.getElementById("pal-name");
    if (filename.value.search(/[\.\<\>\\\/\*]+$/g) != -1) {
        errors.push("Invalid file name:");
        errors.push("Disallowed character.");
    }
    setErrors(errors);
}
function onLoad() {
    createPage();
    validate();
}
function rgb2str(color) {
    let r = color.r.toString(16).toUpperCase();
    if (r.length == 1)
        r = "0" + r;
    let g = color.g.toString(16).toUpperCase();
    if (g.length == 1)
        g = "0" + g;
    let b = color.b.toString(16).toUpperCase();
    if (b.length == 1)
        b = "0" + b;
    return "#" + r + g + b;
}
function str2rgb(hex) {
    if (hex[0] == "#") {
        hex = hex.substr(1);
    }
    const chunkSize = (hex.length == 3) ? 1 : 2;
    const r = "0x" + hex.substr(0, chunkSize);
    const g = "0x" + hex.substr(chunkSize, chunkSize);
    const b = "0x" + hex.substr(chunkSize * 2, chunkSize);
    return {
        r: parseInt(r), g: parseInt(g), b: parseInt(b)
    };
}
function hsv2rgb(color) {
    if (color.h < 0.0)
        color.h = 360.0 + color.h;
    else if (color.h >= 360.0)
        color.h = 0 + (color.h - 360.0);
    const c = (color.s * 0.01) * (color.v * 0.01);
    const x = c * (1 - Math.abs((color.h / 60.0) % 2 - 1));
    const m = (color.v * 0.01) - c;
    let r, g, b;
    if (color.h >= 0.0 && color.h < 60.0) {
        r = c;
        g = x;
        b = 0;
    }
    else if (color.h >= 60.0 && color.h < 120.0) {
        r = x;
        g = c;
        b = 0;
    }
    else if (color.h >= 120.0 && color.h < 180.0) {
        r = 0;
        g = c;
        b = x;
    }
    else if (color.h >= 180.0 && color.h < 240.0) {
        r = 0;
        g = x;
        b = c;
    }
    else if (color.h >= 240.0 && color.h < 300.0) {
        r = x;
        g = 0;
        b = c;
    }
    else if (color.h >= 300.0 && color.h < 360) {
        r = c;
        g = 0;
        b = x;
    }
    return {
        r: Math.round((r + m) * 255),
        g: Math.round((g + m) * 255),
        b: Math.round((b + m) * 255),
    };
}
var g_samplers = [];
var g_accumulator = 0;
///////////////////////////////////////////////////////////////////////////////
// Linear RGB Sampler
function generateColorsLerp(start, end, count) {
    const dr = (end.r - start.r) / (count - 1);
    const dg = (end.g - start.g) / (count - 1);
    const db = (end.b - start.b) / (count - 1);
    const colors = [];
    for (let i = 0; i < count; i++) {
        colors.push({
            r: Math.round(start.r + (dr * i)),
            g: Math.round(start.g + (dg * i)),
            b: Math.round(start.b + (db * i))
        });
    }
    return colors;
}
class LinearRGBSampler {
    id() {
        return "linear";
    }
    htmlID() {
        return this._htmlID;
    }
    constructor(htmlID, start = { r: 0, g: 0, b: 0 }, end = { r: 255, g: 255, b: 255 }, num = 16) {
        this._htmlID = htmlID;
        this.start = start;
        this.end = end;
        this.num = num;
    }
    serialize() {
        return "LinearRGBSampler:" + JSON.stringify(this);
    }
    static deserialize(code) {
        const params = JSON.parse(code);
        return new LinearRGBSampler(params._htmlID, params.start, params.end, params.num);
    }
    sample() {
        return generateColorsLerp(this.start, this.end, this.num);
    }
    createHTML() {
        const id = "sampler-" + this._htmlID;
        const tr = document.createElement("tr");
        tr.id = id;
        const td = [
            document.createElement("td"),
            document.createElement("td"),
            document.createElement("td")
        ];
        td[0].innerHTML = "Linear<br/><i>(RGB)</i>";
        td[0].classList.add("pseudo-th");
        const innerTbl = document.createElement("div");
        innerTbl.classList.add("parameters-list", "parameters-list-linear");
        const innerDivs = [
            document.createElement("div"),
            document.createElement("div"),
            document.createElement("div")
        ];
        const startColorID = id + "-start";
        const startColor = document.createElement("input");
        startColor.type = "color";
        startColor.id = startColorID;
        startColor.value = rgb2str(this.start);
        startColor.onchange = () => {
            this.start = str2rgb(startColor.value);
            syncPaletteView();
        };
        const startLbl = document.createElement("label");
        startLbl.htmlFor = startColorID;
        startLbl.textContent = "Start:";
        innerDivs[0].append(startLbl, document.createElement("br"), startColor);
        const endColorID = id + "-end";
        const endColor = document.createElement("input");
        endColor.type = "color";
        endColor.id = endColorID;
        endColor.value = rgb2str(this.end);
        endColor.onchange = () => {
            this.end = str2rgb(endColor.value);
            syncPaletteView();
        };
        const endLbl = document.createElement("label");
        endLbl.htmlFor = endColorID;
        endLbl.textContent = "End:";
        innerDivs[1].append(endLbl, document.createElement("br"), endColor);
        const numColorsID = id + "-num";
        const numColors = document.createElement("input");
        numColors.type = "number";
        numColors.id = numColorsID;
        numColors.min = "1";
        numColors.max = "255";
        numColors.step = "1";
        numColors.value = this.num.toString();
        numColors.size = 4;
        numColors.onchange = () => {
            let value = parseInt(numColors.value);
            value = Math.max(value, parseInt(numColors.min));
            value = Math.min(value, parseInt(numColors.max));
            this.num = value;
            numColors.value = value.toString();
            syncPaletteView();
        };
        const numLbl = document.createElement("label");
        numLbl.htmlFor = numColorsID;
        numLbl.textContent = "Count:";
        innerDivs[2].append(numLbl, document.createElement("br"), numColors);
        innerTbl.append(innerDivs[0], innerDivs[1], innerDivs[2]);
        td[1].appendChild(innerTbl);
        tr.append(td[0], td[1], td[2]);
        return tr;
    }
}
///////////////////////////////////////////////////////////////////////////////
// Linear sRGB Sampler
function linear2srgb(val) {
    val = val / 255.0;
    val = val ** 2.2;
    return Math.round(val * 255);
}
class LinearSRGBSampler {
    id() {
        return "linear-srgb";
    }
    htmlID() {
        return this._htmlID;
    }
    constructor(htmlID, start = { r: 0, g: 0, b: 0 }, end = { r: 255, g: 255, b: 255 }, num = 16) {
        this._htmlID = htmlID;
        this.start = start;
        this.end = end;
        this.num = num;
    }
    serialize() {
        return "LinearSRGBSampler:" + JSON.stringify(this);
    }
    static deserialize(code) {
        const params = JSON.parse(code);
        return new LinearSRGBSampler(params._htmlID, params.start, params.end, params.num);
    }
    sample() {
        const dr = (this.end.r - this.start.r) / (this.num - 1);
        const dg = (this.end.g - this.start.g) / (this.num - 1);
        const db = (this.end.b - this.start.b) / (this.num - 1);
        const colors = [];
        for (let i = 0; i < this.num; i++) {
            colors.push({
                r: linear2srgb(Math.round(this.start.r + (dr * i))),
                g: linear2srgb(Math.round(this.start.g + (dg * i))),
                b: linear2srgb(Math.round(this.start.b + (db * i)))
            });
        }
        return colors;
    }
    createHTML() {
        const id = "sampler-" + this._htmlID;
        const tr = document.createElement("tr");
        tr.id = id;
        const td = [
            document.createElement("td"),
            document.createElement("td"),
            document.createElement("td")
        ];
        td[0].innerHTML = "Linear<br/><i>(sRGB)</i>";
        td[0].classList.add("pseudo-th");
        const innerTbl = document.createElement("div");
        innerTbl.classList.add("parameters-list", "parameters-list-linear");
        const innerDivs = [
            document.createElement("div"),
            document.createElement("div"),
            document.createElement("div")
        ];
        const startColorID = id + "-start";
        const startColor = document.createElement("input");
        startColor.type = "color";
        startColor.id = startColorID;
        startColor.value = rgb2str(this.start);
        startColor.onchange = () => {
            this.start = str2rgb(startColor.value);
            syncPaletteView();
        };
        const startLbl = document.createElement("label");
        startLbl.htmlFor = startColorID;
        startLbl.textContent = "Start:";
        innerDivs[0].append(startLbl, document.createElement("br"), startColor);
        const endColorID = id + "-end";
        const endColor = document.createElement("input");
        endColor.type = "color";
        endColor.id = endColorID;
        endColor.value = rgb2str(this.end);
        endColor.onchange = () => {
            this.end = str2rgb(endColor.value);
            syncPaletteView();
        };
        const endLbl = document.createElement("label");
        endLbl.htmlFor = endColorID;
        endLbl.textContent = "End:";
        innerDivs[1].append(endLbl, document.createElement("br"), endColor);
        const numColorsID = id + "-num";
        const numColors = document.createElement("input");
        numColors.type = "number";
        numColors.id = numColorsID;
        numColors.min = "1";
        numColors.max = "255";
        numColors.step = "1";
        numColors.value = this.num.toString();
        numColors.size = 4;
        numColors.onchange = () => {
            let value = parseInt(numColors.value);
            value = Math.max(value, parseInt(numColors.min));
            value = Math.min(value, parseInt(numColors.max));
            this.num = value;
            numColors.value = value.toString();
            syncPaletteView();
        };
        const numLbl = document.createElement("label");
        numLbl.htmlFor = numColorsID;
        numLbl.textContent = "Count:";
        innerDivs[2].append(numLbl, document.createElement("br"), numColors);
        innerTbl.append(innerDivs[0], innerDivs[1], innerDivs[2]);
        td[1].appendChild(innerTbl);
        tr.append(td[0], td[1], td[2]);
        return tr;
    }
}
///////////////////////////////////////////////////////////////////////////////
// Bezier Fast Sampler
function linear2quadbez_fast(t, p1) {
    t = t / 255.0;
    return Math.round(((2.0 * (1.0 - t) * t * p1) + (t * t)) * 255);
}
class BezierFastSampler {
    id() {
        return "bezier-fast";
    }
    htmlID() {
        return this._htmlID;
    }
    constructor(htmlID, start = { r: 0, g: 0, b: 0 }, end = { r: 255, g: 255, b: 255 }, num = 16, controlPoint = 0.25) {
        this._htmlID = htmlID;
        this.start = start;
        this.end = end;
        this.num = num;
        this.controlPoint = controlPoint;
    }
    serialize() {
        return "BezierFastSampler:" + JSON.stringify(this);
    }
    static deserialize(code) {
        const params = JSON.parse(code);
        return new BezierFastSampler(params._htmlID, params.start, params.end, params.num, params.controlPoint);
    }
    sample() {
        const linColors = generateColorsLerp(this.start, this.end, this.num);
        const colors = [];
        linColors.forEach(color => {
            colors.push({
                r: linear2quadbez_fast(color.r, this.controlPoint),
                g: linear2quadbez_fast(color.g, this.controlPoint),
                b: linear2quadbez_fast(color.b, this.controlPoint)
            });
        });
        return colors;
    }
    createHTML() {
        const id = "sampler-" + this._htmlID;
        const tr = document.createElement("tr");
        tr.id = id;
        const td = [
            document.createElement("td"),
            document.createElement("td"),
            document.createElement("td")
        ];
        td[0].innerHTML = "Bézier<br/><i>(Fast)</i>";
        td[0].classList.add("pseudo-th");
        const innerTbl = document.createElement("div");
        innerTbl.classList.add("parameters-list", "parameters-list-bezier1");
        const innerDivs = [
            document.createElement("div"),
            document.createElement("div"),
            document.createElement("div"),
            document.createElement("div")
        ];
        const startColorID = id + "-start";
        const startColor = document.createElement("input");
        startColor.type = "color";
        startColor.id = startColorID;
        startColor.value = rgb2str(this.start);
        startColor.onchange = () => {
            this.start = str2rgb(startColor.value);
            syncPaletteView();
        };
        const startLbl = document.createElement("label");
        startLbl.htmlFor = startColorID;
        startLbl.textContent = "Start:";
        innerDivs[0].append(startLbl, document.createElement("br"), startColor);
        const endColorID = id + "-end";
        const endColor = document.createElement("input");
        endColor.type = "color";
        endColor.id = endColorID;
        endColor.value = rgb2str(this.end);
        endColor.onchange = () => {
            this.end = str2rgb(endColor.value);
            syncPaletteView();
        };
        const endLbl = document.createElement("label");
        endLbl.htmlFor = endColorID;
        endLbl.textContent = "End:";
        innerDivs[1].append(endLbl, document.createElement("br"), endColor);
        const numColorsID = id + "-num";
        const numColors = document.createElement("input");
        numColors.type = "number";
        numColors.id = numColorsID;
        numColors.min = "1";
        numColors.max = "255";
        numColors.step = "1";
        numColors.value = this.num.toString();
        numColors.size = 4;
        numColors.onchange = () => {
            let value = parseInt(numColors.value);
            value = Math.max(value, parseInt(numColors.min));
            value = Math.min(value, parseInt(numColors.max));
            this.num = value;
            numColors.value = value.toString();
            syncPaletteView();
        };
        const numLbl = document.createElement("label");
        numLbl.htmlFor = numColorsID;
        numLbl.textContent = "Count:";
        innerDivs[2].append(numLbl, document.createElement("br"), numColors);
        const ctrlPntID = id + "-cp";
        const ctrlPnt = document.createElement("input");
        ctrlPnt.type = "number";
        ctrlPnt.id = ctrlPntID;
        ctrlPnt.min = "0.0";
        ctrlPnt.max = "1.0";
        ctrlPnt.step = "0.01";
        ctrlPnt.value = this.controlPoint.toString();
        ctrlPnt.size = 4;
        ctrlPnt.onchange = () => {
            let value = parseFloat(ctrlPnt.value);
            value = Math.max(value, parseFloat(ctrlPnt.min));
            value = Math.min(value, parseFloat(ctrlPnt.max));
            this.controlPoint = value;
            ctrlPnt.value = value.toString();
            syncPaletteView();
        };
        const cpLbl = document.createElement("label");
        cpLbl.htmlFor = ctrlPntID;
        cpLbl.textContent = "Control Point:";
        innerDivs[3].append(cpLbl, document.createElement("br"), ctrlPnt);
        innerTbl.append(innerDivs[0], innerDivs[1], innerDivs[2], innerDivs[3]);
        td[1].appendChild(innerTbl);
        tr.append(td[0], td[1], td[2]);
        return tr;
    }
}
///////////////////////////////////////////////////////////////////////////////
// Bezier Sampler
function quadBezierEq(t, p) {
    return (2.0 * (1.0 - t) * t * p) + (t * t);
}
function quadBezierTFromX(p, x, tStep = 0.1, tSet = 0, precision = 0.0001) {
    let tSet2 = tSet;
    let xSet2 = 0.0;
    if (tStep < precision)
        return tSet;
    while (xSet2 < x) {
        tSet = tSet2;
        tSet2 = tSet2 + tStep;
        xSet2 = quadBezierEq(tSet2, p);
    }
    return quadBezierTFromX(p, x, tStep * 0.5, tSet);
}
function linear2quadbez(x, p) {
    x = x / 255.0;
    const t = quadBezierTFromX(p[0], x);
    const y = quadBezierEq(t, p[1]);
    return Math.round(y * 255);
}
class BezierQuadraticSampler {
    id() {
        return "bezier-quad";
    }
    htmlID() {
        return this._htmlID;
    }
    constructor(htmlID, start = { r: 0, g: 0, b: 0 }, end = { r: 255, g: 255, b: 255 }, num = 16, controlPoint = [0.50, 0.15]) {
        this._htmlID = htmlID;
        this.start = start;
        this.end = end;
        this.num = num;
        this.controlPoint = controlPoint;
    }
    serialize() {
        return "BezierQuadraticSampler:" + JSON.stringify(this);
    }
    static deserialize(code) {
        const params = JSON.parse(code);
        return new BezierQuadraticSampler(params._htmlID, params.start, params.end, params.num, params.controlPoint);
    }
    sample() {
        const linColors = generateColorsLerp(this.start, this.end, this.num);
        const colors = [];
        linColors.forEach(color => {
            colors.push({
                r: linear2quadbez(color.r, this.controlPoint),
                g: linear2quadbez(color.g, this.controlPoint),
                b: linear2quadbez(color.b, this.controlPoint)
            });
        });
        return colors;
    }
    createHTML() {
        const id = "sampler-" + this._htmlID;
        const tr = document.createElement("tr");
        tr.id = id;
        const td = [
            document.createElement("td"),
            document.createElement("td"),
            document.createElement("td")
        ];
        td[0].innerHTML = "Bézier<br/><i>(Quadratic)</i>";
        td[0].classList.add("pseudo-th");
        const innerTbl = document.createElement("div");
        innerTbl.classList.add("parameters-list", "parameters-list-bezier2");
        const innerDivs = [
            document.createElement("div"),
            document.createElement("div"),
            document.createElement("div"),
            document.createElement("div")
        ];
        const startColorID = id + "-start";
        const startColor = document.createElement("input");
        startColor.type = "color";
        startColor.id = startColorID;
        startColor.value = rgb2str(this.start);
        startColor.onchange = () => {
            this.start = str2rgb(startColor.value);
            syncPaletteView();
        };
        const startLbl = document.createElement("label");
        startLbl.htmlFor = startColorID;
        startLbl.textContent = "Start:";
        innerDivs[0].append(startLbl, document.createElement("br"), startColor);
        const endColorID = id + "-end";
        const endColor = document.createElement("input");
        endColor.type = "color";
        endColor.id = endColorID;
        endColor.value = rgb2str(this.end);
        endColor.onchange = () => {
            this.end = str2rgb(endColor.value);
            syncPaletteView();
        };
        const endLbl = document.createElement("label");
        endLbl.htmlFor = endColorID;
        endLbl.textContent = "End:";
        innerDivs[1].append(endLbl, document.createElement("br"), endColor);
        const numColorsID = id + "-num";
        const numColors = document.createElement("input");
        numColors.type = "number";
        numColors.id = numColorsID;
        numColors.min = "1";
        numColors.max = "255";
        numColors.step = "1";
        numColors.value = this.num.toString();
        numColors.size = 4;
        numColors.onchange = () => {
            let value = parseInt(numColors.value);
            value = Math.max(value, parseInt(numColors.min));
            value = Math.min(value, parseInt(numColors.max));
            this.num = value;
            numColors.value = value.toString();
            syncPaletteView();
        };
        const numLbl = document.createElement("label");
        numLbl.htmlFor = numColorsID;
        numLbl.textContent = "Count:";
        innerDivs[2].append(numLbl, document.createElement("br"), numColors);
        const ctrlPntXID = id + "-cp-x";
        const ctrlPntX = document.createElement("input");
        ctrlPntX.type = "number";
        ctrlPntX.id = ctrlPntXID;
        ctrlPntX.min = "0.0";
        ctrlPntX.max = "1.0";
        ctrlPntX.step = "0.01";
        ctrlPntX.value = this.controlPoint[0].toString();
        ctrlPntX.size = 4;
        ctrlPntX.onchange = () => {
            let value = parseFloat(ctrlPntX.value);
            value = Math.max(value, parseFloat(ctrlPntX.min));
            value = Math.min(value, parseFloat(ctrlPntX.max));
            this.controlPoint[0] = value;
            ctrlPntX.value = value.toString();
            syncPaletteView();
        };
        const ctrlPntYID = id + "-cp-y";
        const ctrlPntY = document.createElement("input");
        ctrlPntY.type = "number";
        ctrlPntY.id = ctrlPntYID;
        ctrlPntY.min = "0.0";
        ctrlPntY.max = "1.0";
        ctrlPntY.step = "0.01";
        ctrlPntY.value = this.controlPoint[1].toString();
        ctrlPntY.size = 4;
        ctrlPntY.onchange = () => {
            let value = parseFloat(ctrlPntY.value);
            value = Math.max(value, parseFloat(ctrlPntY.min));
            value = Math.min(value, parseFloat(ctrlPntY.max));
            this.controlPoint[1] = value;
            ctrlPntY.value = value.toString();
            syncPaletteView();
        };
        const cpLbl = document.createElement("label");
        cpLbl.textContent = "Control Point:";
        innerDivs[3].append(cpLbl, document.createElement("br"), ctrlPntX, ctrlPntY);
        innerTbl.append(innerDivs[0], innerDivs[1], innerDivs[2], innerDivs[3]);
        td[1].appendChild(innerTbl);
        tr.append(td[0], td[1], td[2]);
        return tr;
    }
}
///////////////////////////////////////////////////////////////////////////////
// HSV Sampler
class HSVSampler {
    id() {
        return "hsv";
    }
    htmlID() {
        return this._htmlID;
    }
    constructor(htmlID, start = { h: 0, s: 100, v: 100 }, end = { h: 360, s: 30, v: 30 }, hueCount = 8, satCount = 3, valCount = 3) {
        this._htmlID = htmlID;
        this.start = start;
        this.end = end;
        this.hueCount = hueCount;
        this.satCount = satCount;
        this.valCount = valCount;
    }
    serialize() {
        return "HSVSampler:" + JSON.stringify(this);
    }
    static deserialize(code) {
        const params = JSON.parse(code);
        return new HSVSampler(params._htmlID, params.start, params.end, params.hueCount, params.satCount, params.valCount);
    }
    sample() {
        const hStep = (this.end.h - this.start.h) / (this.hueCount - 1);
        const sStep = (this.end.s - this.start.s) / (this.satCount - 1);
        const vStep = (this.end.v - this.start.v) / (this.valCount - 1);
        const colors = [];
        for (let sIndex = 0; sIndex < this.satCount; sIndex++) {
            const s = Math.round((sIndex * sStep) + this.start.s);
            for (let vIndex = 0; vIndex < this.valCount; vIndex++) {
                const v = Math.round((vIndex * vStep) + this.start.v);
                for (let hIndex = 0; hIndex < this.hueCount; hIndex++) {
                    const h = Math.round((hIndex * hStep) + this.start.h);
                    colors.push({ h: h, v: v, s: s });
                }
            }
        }
        return colors.map(color => {
            return hsv2rgb(color);
        });
    }
    createHTML() {
        const id = "sampler-" + this._htmlID;
        const tr = document.createElement("tr");
        tr.id = id;
        const td = [
            document.createElement("td"),
            document.createElement("td"),
            document.createElement("td")
        ];
        td[0].innerHTML = "Hue<br/>Saturation</br>Value";
        td[0].classList.add("pseudo-th");
        const innerTbl = document.createElement("div");
        innerTbl.classList.add("parameters-tbl");
        const header = document.createElement("div");
        const headerCells = [
            document.createElement("div"),
            document.createElement("div"),
            document.createElement("div"),
            document.createElement("div")
        ];
        headerCells[1].textContent = "Hue";
        headerCells[2].textContent = "Saturation";
        headerCells[3].textContent = "Value";
        header.append(headerCells[0], headerCells[1], headerCells[2], headerCells[3]);
        const body = document.createElement("div");
        const bodyRows = [
            document.createElement("div"),
            document.createElement("div"),
            document.createElement("div")
        ];
        const startCells = [
            document.createElement("div"),
            document.createElement("div"),
            document.createElement("div"),
            document.createElement("div")
        ];
        startCells[0].textContent = "Start: ";
        const startHueID = id + "-start-hue";
        const startHue = document.createElement("input");
        startHue.type = "number";
        startHue.id = startHueID;
        startHue.min = "0";
        startHue.max = "360";
        startHue.step = "1";
        startHue.value = this.start.h.toString();
        startHue.onchange = () => {
            this.start.h = parseInt(startHue.value);
            syncPaletteView();
        };
        startCells[1].appendChild(startHue);
        const startSatID = id + "-start-sat";
        const startSat = document.createElement("input");
        startSat.type = "number";
        startSat.id = startSatID;
        startSat.min = "0";
        startSat.max = "100";
        startSat.step = "1";
        startSat.value = this.start.s.toString();
        startSat.onchange = () => {
            let value = parseInt(startSat.value);
            value = Math.max(value, parseInt(startSat.min));
            value = Math.min(value, parseInt(startSat.max));
            this.start.s = value;
            startSat.value = value.toString();
            syncPaletteView();
        };
        startCells[2].appendChild(startSat);
        const startValID = id + "-start-val";
        const startVal = document.createElement("input");
        startVal.type = "number";
        startVal.id = startValID;
        startVal.min = "0";
        startVal.max = "100";
        startVal.step = "1";
        startVal.value = this.start.v.toString();
        startVal.onchange = () => {
            let value = parseInt(startVal.value);
            value = Math.max(value, parseInt(startVal.min));
            value = Math.min(value, parseInt(startVal.max));
            this.start.v = value;
            startVal.value = value.toString();
            syncPaletteView();
        };
        startCells[3].appendChild(startVal);
        const endCells = [
            document.createElement("div"),
            document.createElement("div"),
            document.createElement("div"),
            document.createElement("div")
        ];
        endCells[0].textContent = "End: ";
        const endHueID = id + "-end-hue";
        const endHue = document.createElement("input");
        endHue.type = "number";
        endHue.id = endHueID;
        endHue.min = "0";
        endHue.max = "360";
        endHue.step = "1";
        endHue.value = this.end.h.toString();
        endHue.onchange = () => {
            this.end.h = parseInt(endHue.value);
            syncPaletteView();
        };
        endCells[1].appendChild(endHue);
        const endSatID = id + "-end-sat";
        const endSat = document.createElement("input");
        endSat.type = "number";
        endSat.id = endSatID;
        endSat.min = "0";
        endSat.max = "100";
        endSat.step = "1";
        endSat.value = this.end.s.toString();
        endSat.onchange = () => {
            let value = parseInt(endSat.value);
            value = Math.max(value, parseInt(endSat.min));
            value = Math.min(value, parseInt(endSat.max));
            this.end.s = value;
            endSat.value = value.toString();
            syncPaletteView();
        };
        endCells[2].appendChild(endSat);
        const endValID = id + "-end-val";
        const endVal = document.createElement("input");
        endVal.type = "number";
        endVal.id = endValID;
        endVal.min = "0";
        endVal.max = "100";
        endVal.step = "1";
        endVal.value = this.end.v.toString();
        endVal.onchange = () => {
            let value = parseInt(endVal.value);
            value = Math.max(value, parseInt(endVal.min));
            value = Math.min(value, parseInt(endVal.max));
            this.end.v = value;
            endVal.value = value.toString();
            syncPaletteView();
        };
        endCells[3].appendChild(endVal);
        const countCells = [
            document.createElement("td"),
            document.createElement("td"),
            document.createElement("td"),
            document.createElement("td")
        ];
        countCells[0].textContent = "Bands: ";
        const hueCountID = id + "-hues";
        const hueCount = document.createElement("input");
        hueCount.type = "number";
        hueCount.id = hueCountID;
        hueCount.min = "1";
        hueCount.max = "99";
        hueCount.step = "1";
        hueCount.value = this.hueCount.toString();
        hueCount.onchange = () => {
            let value = parseInt(hueCount.value);
            value = Math.max(value, parseInt(hueCount.min));
            value = Math.min(value, parseInt(hueCount.max));
            this.hueCount = value;
            hueCount.value = value.toString();
            syncPaletteView();
        };
        countCells[1].appendChild(hueCount);
        const satCountID = id + "-sats";
        const satCount = document.createElement("input");
        satCount.type = "number";
        satCount.id = satCountID;
        satCount.min = "1";
        satCount.max = "99";
        satCount.step = "1";
        satCount.value = this.satCount.toString();
        satCount.onchange = () => {
            let value = parseInt(satCount.value);
            value = Math.max(value, parseInt(satCount.min));
            value = Math.min(value, parseInt(satCount.max));
            this.satCount = value;
            satCount.value = value.toString();
            syncPaletteView();
        };
        countCells[2].appendChild(satCount);
        const valCountID = id + "-vals";
        const valCount = document.createElement("input");
        valCount.type = "number";
        valCount.id = valCountID;
        valCount.min = "1";
        valCount.max = "99";
        valCount.step = "1";
        valCount.value = this.valCount.toString();
        valCount.onchange = () => {
            let value = parseInt(valCount.value);
            value = Math.max(value, parseInt(valCount.min));
            value = Math.min(value, parseInt(valCount.max));
            this.valCount = value;
            valCount.value = value.toString();
            syncPaletteView();
        };
        countCells[3].appendChild(valCount);
        header.append(headerCells[0], headerCells[1], headerCells[2], headerCells[3]);
        bodyRows[0].append(startCells[0], startCells[1], startCells[2], startCells[3]);
        bodyRows[1].append(endCells[0], endCells[1], endCells[2], endCells[3]);
        bodyRows[2].append(countCells[0], countCells[1], countCells[2], countCells[3]);
        innerTbl.append(header, bodyRows[0], bodyRows[1], bodyRows[2]);
        td[1].appendChild(innerTbl);
        tr.append(td[0], td[1], td[2]);
        return tr;
    }
}
function getColorsFrom(samplers) {
    let colors = [];
    samplers.forEach(sampler => { colors = colors.concat(sampler.sample()); });
    return colors;
}
function getSamplers() {
    return g_samplers;
}
function setSamplers(samplers) {
    g_samplers = samplers;
}
function genSamplerID() {
    g_accumulator++;
    return g_accumulator;
}
function resetSamplers() {
    g_samplers = [];
    g_accumulator = 0;
    const properties = document.getElementById("properties");
    properties.innerHTML = "";
}
function removeDuplicates(colors) {
    let cleanedColors = [];
    colors.forEach(color => {
        const duplicate = cleanedColors.find(color2 => {
            const equality = (color.r == color2.r) &&
                (color.g == color2.g) &&
                (color.b == color2.b);
            return equality;
        });
        if (!duplicate)
            cleanedColors.push(color);
    });
    return cleanedColors;
}
